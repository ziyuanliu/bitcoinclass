#!/usr/bin/env python3
"""
Transaction component

Will include data structures to allow for the addition of transactions
"""
import logging
import time

from utils import sha256d
from typing import Mapping, NamedTuple, Union, Iterable
from serialization import register_namedtuple

logger = logging.getLogger(__name__)


@register_namedtuple
class OutPoint(NamedTuple):
    """
    https://bitcoin.org/en/glossary/outpoint
    refers to a particular Output (https://bitcoin.org/en/glossary/output)
    OutPoint:
    - 32-byte TXID
    - 4-byte output index number (vout)
    """

    txid: str
    txout_idx: int


@register_namedtuple
class SignatureScript(NamedTuple):
    """
    https://bitcoin.org/en/glossary/signature-script
    Data generated by a spender which is almost always used as variables to satisfy a pubkey script
    """

    unlock_sig: bytes
    unlock_pk: bytes


@register_namedtuple
class TxIn(NamedTuple):
    """
    https://bitcoin.org/en/glossary/input
    fields:
    - outpoint: references to particular transaction output
    - signature: signature to satify spending generated by the user
    - sequence: the sequence number of the transaction: https://bitcoin.org/en/glossary/sequence-number
    """

    outpoint: Union[OutPoint, None]
    signature: SignatureScript
    sequence: int


@register_namedtuple
class TxOut(NamedTuple):
    """
    https://bitcoin.org/en/glossary/output
    fields:
    - value: 0 or more minis
    - pubkey: public key of the owner of this txn
    """

    value: int
    pubkey: str


@register_namedtuple
class UnspentTxOut(NamedTuple):
    """
    Unspent output, UnspentTXOutput :)
    """

    value: int
    pubkey: str

    # reference of the transaction this output belong to, easier to store the
    # values
    txid: str
    txout_idx: int

    # Did this transaction come out of the coinbase transaction
    is_coinbase: bool

    # The blockchain height the output was included in the chain
    height: int

    @property
    def outpoint(self):
        return OutPoint(self.txid, self.txout_idx)


@register_namedtuple
class Transaction(NamedTuple):
    """
    A NamedTuple to represent a transaction
    """

    txins: Iterable[TxIn]
    txouts: Iterable[TxOut]

    # The block number or timestamp at which this transaction is unlocked.
    # < 500000000: Block number at which this transaction is unlocked.
    # >= 500000000: UNIX timestamp at which this transaction is unlocked.
    locktime: int = None

    @property
    def is_coinbase(self) -> bool:
        """
        coinbase: first transaction of the block
        """

        return len(self.txins) == 1 and self.txins[0].outpoint is None

    @classmethod
    def create_coinbase(cls, pay_to_addr, value):
        """
        Push current block height into unlock_sig so that this
        transaction's ID is unique relative to other coinbase txns.
        """

        signature = SignatureScript(
            unlock_sig=str(time.time()).encode(),
            unlock_pk=None
        )
        first_txin = TxIn(outpoint=None, signature=signature, sequence=0)
        first_txout = TxOut(value=value, pubkey=pay_to_addr)

        return cls(txins=[first_txin], txouts=[first_txout])
    
    @property
    def id(self) -> str:
        return sha256d(self.serialize())


@register_namedtuple
class MerkleNode(NamedTuple):
    value: str
    children: Iterable = None

    @classmethod
    def generate_root_from_transaction(cls, txns):
        txn_hashes = tuple(MerkleNode(value=sha256d(txn.id)) for txn in txns)

        # we expect to have an even number of leaves
        def even_chunks(l):
            if len(l) % 2 == 1:
                l = l + (l[-1],)
            return (l[i:i + 2] for i in range(0, len(l), 2))

        while len(txn_hashes) > 1:
            even_txns = tuple(even_chunks(txn_hashes))
            txn_hashes = tuple(
                MerkleNode(value=sha256d(left.value+right.value), children=[left, right]) 
                for [left, right] in even_txns
            )

        return txn_hashes[0]


utxo_set: Mapping[OutPoint, UnspentTxOut] = {}


def get_utxos_for_addr(pubkey: str) -> UnspentTxOut:
    return [utxo for utxo in utxo_set.values() if utxo.pubkey == pubkey]


def get_current_balance_for_addr(pubkey: str) -> int:
    return sum(utxo.value for utxo in get_utxos_for_addr(pubkey))


def add_to_utxo(txout, tx, idx, is_coinbase, height):
    utxo = UnspentTxOut(*txout, txid=tx.id, txout_idx=idx, is_coinbase=is_coinbase, height=height)
    logger.info(f'adding tx outpoint {utxo.outpoint} to utxo_set')
    utxo_set[utxo.outpoint] = utxo


def rm_from_utxo(txid, txout_idx):
    del utxo_set[OutPoint(txid, txout_idx)]


def find_utxo_in_list(txin, txns) -> UnspentTxOut:
    txid, txout_idx = txin.outpoint
    try:
        txout = [t for t in txns if t.id == txid][0].txouts[txout_idx]
    except Exception as e:
        return None

    return UnspentTxOut(*txout, txid=txid, is_coinbase=False, height=-1, txout_idx=txout_idx)
